

// The API for the data stores running in the UI.
// Running all API access through here allows for easy porting later.
var API = exports.API = Object.create(require("./ui._common.model").API);
API.BACKBONE = require('backbone');
API.FIRENODE = require("firenode-for-jsonapi/client");


exports.makeEndpointUrl = function (name) {

//console.log("window.location.origin: ", window.location.origin);

//for (var name in window.location) {
//	console.log("window.location." + name + ": ", window.location[name]);
//}

	return (
		window.location.origin ||
		(window.location.protocol + "//" + window.location.host)
	) + "/api/v1/" + name;
}



exports.init = function (sessionToken, context) {

//	var client = new API.FIRENODE.Client(sessionToken, context);

//console.log("API.FIRENODE.client", client);

}




// Resolve foreign keys by collecting all used keys and batch-querying
// the backend for values if not already found in loaded collection.

// OPTIMIZE: Pre-load collections with data using one larger data structure
//           generated by the server using SQL joins instead of loading data
//           per collection on demand.
//           To generate SQL needed to preload data, let this function collect
//           the metadata it uses to resolve calls at runtime and derive the query
//           from there.

exports.resolveForeignKeys = function (store, records, keys, wait, options) {

	var callerStack = new Error().stack;

	if (records.length === 0) {
		if (wait) {
			return API.Q.resolve([]);
		} else {
			return [];
		}
	}

	var key_ids = {};
	var key_id_map = {};

	records.forEach(function (record, i) {
		Object.keys(keys).forEach(function (key) {
			if (!key_ids[key]) {
				key_ids[key] = {};
			}
			if (!key_id_map[key]) {
				key_id_map[key] = {};
			}
			key_id_map[key][i] = record.get(key);
			if (!key_ids[key][key_id_map[key][i]]) {
				key_ids[key][key_id_map[key][i]] = [];
			}
			key_ids[key][key_id_map[key][i]].push(i);
		});
	});

	var idFieldName = (options && options.useIdField) || "id";

	var promises = Object.keys(keys).map(function (key) {
		// Resolve IDs and RE-render UI once resolved
		return keys[key].store['for']({
			ids: Object.keys(key_ids[key])
		}).then(function (foreignStore) {
			Object.keys(key_ids[key]).forEach(function (foreign_key) {
				key_ids[key][foreign_key].forEach(function (i) {
					
					if (!store._byId[records[i].get(idFieldName)]) {

						console.error("key", key);
						console.error("foreign_key", foreign_key);
						console.log("idFieldName", idFieldName);
						console.log("records[i].get(idFieldName)", records[i].get(idFieldName));
						console.error("store._byId", store._byId);
						console.error("store", store);
						console.error("callerStack", callerStack);
						throw new Error("Record by " + idFieldName + " '" + records[i].get(idFieldName) + "' not found!");
					}
					if (!records[i].__model) {
						return;
					}
					try {
						// Assign all properties from the model.
						// TODO: Only assign subscribed properties.
						if (keys[key].model) {
							var record = foreignStore.get(foreign_key);
							// NOTE: Sometimes this is not yet available due to 'for' call on
							//       store not waiting long enough.
							// TODO: Wait long enough for records to always be available.
							if (record) {
								var model = new keys[key].model(record.toJSON());
								var values = model.getValues();
/*
								var values = model.getAttributes({
								  props: true,
								  session: true,
								  derived: true
								});
*/
								Object.keys(values).forEach(function (name) {
									records[i].__model.set(keys[key].localFieldPrefix + "." + name, values[name]);
								});
							}
						} else
						// Assign only one property from the foreign table.
						// TODO: Deprecate
						{
							records[i].__model.set(keys[key].localField, foreignStore.get(foreign_key).get(keys[key].foreignField));
						}
					} catch (err) {
						console.error("key", key);
						console.error("foreign_key", foreign_key);
						console.error(err.stack);
						throw err;
					}
				});
			});
		});
	});

	if (wait) {
		return API.Q.all(promises).then(function () {
			return exports.resolveForeignKeys(store, records, keys, false, options);
		});
	}
	return records;
}




function initLocalStorage () {

	// Ensure local storage is there and hook it up to a backend if not.

    try {
        return "localStorage" in window && window.localStorage != null;
    } catch (e) {

		// TODO: Hook up to backend (via session id) if no local storage supported.

        var data = {},
            undef;
        window.localStorage = {
            setItem     : function(id, val) { return data[id] = String(val); },
            getItem     : function(id) { return data.hasOwnProperty(id) ? data[id] : undef; },
            removeItem  : function(id) { return delete data[id]; },
            clear       : function() { return data = {}; }
        };
    }
}

initLocalStorage();


exports.storeLocalValueFor = function (group, name, value) {
	window.localStorage.setItem(group + "." + name, value);
}

exports.getLocalValueFor = function (group, name) {
	return window.localStorage.getItem(group + "." + name) || null;
}


